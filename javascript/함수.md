# 함수

함수는 자바스크립트 프로그래밍의 꽃이라고 볼 수 있으며, 그만큼 중요하고 활용성이 뛰어나다고 할 수 있습니다. 기초부터 차근차근 알아보도록 하겠습니다.

## 함수 선언문

```js
function plus(x, y) {
  return x + y;
}
```

이 함수는 x, y의 `인자값`을 가지고 있으며 가져온 인자값을 + 연산자를 통해 return을 통해 `반환`하는 함수입니다.<br/>
여기서 주의할 부분은 return문은 절대 줄 바꿈 문자를 넣으면 안됩니다.<br/>
만약 줄 바꿈을 넣게 되면...

```js
function plus(x, y) {
  return;
  x + y;
}
```

위처럼 값이 없이 반환이 되기 때문입니다.<br/>

## 함수명

위에서 든 예시는 plus라는 함수명을 가지고 있습니다. 지금은 하나의 함수만 있어서 바로 구별이 가능하지만 몇십, 백개의 함수와 많은 코드들이 있다면 저 plus라는 함수가 어떤 역할을 하는지 바로 알아챌 수 있을까요?<br/>
물론 알아챌 수는 있지만 시간이 처음보단 오래 걸릴 것입니다. 그래서 함수를 선언하는 것 뿐만 아니라 `함수명`을 정하는 것도 매우 **중요**합니다.<br/>
그렇다면 내가 만드는 함수가 과일의 갯수를 더하는 함수라면?

```js
function getFruitsPlus(x, y) {
  return x + y;
}
```

예시가 조금 추상적이긴 하지만 plus를 가진 함수명보다 훨씬 명확해 진 것을 확인할 수 있습니다. 이처럼 통상적으로 함수명을 지을 떄는 `동사` 혹은 `동사로 시작되는 어휘`로 시작합니다.

## 함수 호출

지금까지 함수를 만들어봤는데 그럼 저 함수를 어떻게 사용하냐구요?<br/>
본인이 선언했던 함수명을 가져와 소괄호로 `인자`를 묶어서 호출합니다.

```js
getFruitsPlus(5, 15); // 20
```

소괄호 안에 5와 15가 들어간 것을 확인할 수 있습니다. 저 5와 15의 인자들은 x와 y의 값을 받아 둘을 함수의 반환값에 맞춰 5 + 15가 되어 20인 결과가 반환됩니다.

## 인수

함수를 선언할 때 인수는 아주 중요한 부분입니다. 인수가 없을 수도, 하나만 있을 수도, 여러개가 있을 수도 있습니다.

```js
var classA = { name: "A", score: 60 };
var classB = { name: "B", score: 80 };

function getScoreAvg(a, b) {
  var totalScore = a.score + b.score;
  return totalScore / 2;
}

getScoreAvg(classA, classB);
```

위 예제처럼 객체를 받아서 사용할 수도 있으며

```js
function makeItLouder() {
  var name = "junjang";
  alert(`${name} 소리질러어어어어어`);
}

makeItLouder();
```

인수를 아예 넘기지 않고 만들 수도 있습니다.

## 함수 끌어올림(호이스팅)

`끌어올림(호이스팅)`에 관해선 `변수` 주제에서도 나왔던 개념입니다. 변수와 마찬가지로 프로그램의 원칙을 따르지 않고 함수 선언문을 `첫 줄`로 끌어올립니다.

```js
isWorking(); // 잘 동작하나?

function isWorking() {
  console.log(`잘 동작하나?`);
}
```

즉, 함수 선언문을 어디에서 사용하든 상관없이 `똑같이 동작한다`는 것입니다.

## 함수에서의 변수

함수를 선언할 때 변수에 접근하여 사용하는 일이 굉장히 많을 것입니다. 하지만 이 변수를 사용 할 수 있는 범위와 사용하지 못하는 범위가 있습니다. 이를 `유효범위(scope)`라고 합니다.<br/>
자바스크립트는 `어휘적 범위(lexical scope)`를 사용하고 있으며 범위는 크게 **두 가지**로 나뉩니다.

- 전역변수 : 함수 바깥에서 선언된 변수로 유효범위가 프로그램 전체
- 지역변수 : 함수 내부에서 선언된 변수로 유효범위는 함수 내부

```js
var global = "전역변수";
function inner() {
  var local = "지역변수";
  console.log(`저는 ${global} 입니다.`); // 저는 전역변수 입니다.
  return local;
}

inner();
console.log(`저는 ${local} 입니다.`); // undefined
```

inner 함수에서 local 변수를 반환했음에도 불구하고 값이 할당이 안된 이유는 `지역 변수`이기 때문에 함수 내부에서만 사용이 가능했기 때문입니다.

### 변수의 충돌

위 예제에서 우린 서로 다른 변수명을 가진 변수들을 다루었습니다. 하지만 변수가 같은 이름이라면 어떻게 될까요?

```js
var korean = "한국사람";
function inner() {
  var korean = "한국인";
  console.log(`저는 ${korean} 입니다.`); // 저는 한국인 입니다.
  return korean;
}

inner();
console.log(`저는 ${korean} 입니다.`); // 저는 한국사람 입니다.
```

보면 같은 korean이라는 변수를 전역, 지역 둘 다 가지고 있는 상태입니다. 서로 **변수명은 같지만** `다른 위치`에서 메모리를 차지하고 있는 상태입니다. 따라서 함수 내부에서는 한국인, 함수 외부에서는 한국사람이 출력됩니다.

## 함수 내부 끌어올림(호이스팅)

자바스크립트 엔진은 함수 안의 변수 선언부를 함수의 첫머리로 끌어올리게 됩니다.

```js
function hello() {
  console.log(hello); // undefined
  var hello = "안녕하세요";
  console.log(hello); // 안녕하세요
}
```

즉, 함수 끌어올림과 마찬가지로 `함수 내부`에서도 동일하게 호이스팅이 발생합니다.

## 함수 리터럴

함수 리터럴은 이름이 없는 함수이므로 `익명 함수` 또는 `무명 함수`로 불립니다. 함수 리터럴을 사용할 때는 몇 가지 중요한 점이 있습니다.

- 끝에 반드시 세미콜론을 붙인다.
- 변수에 함수 객체의 참조를 저장한다.
- 함수 선언문은 호이스팅이 되지만 함수 리터럴은 호이스팅이 일어나지 않는다.
- 변수에 할당되어야 그 이름으로 호출할 수 있다.

위 네 가지 점을 꼭 알아두고 사용하여야 합니다.
간단한 예제로 알아보겠습니다.

```js
var hello = function() {
  console.log("안녕하세요");
};
```

hello라는 변수에 함수 객체의 참조를 저장하였습니다. 원래라면 이 함수는 어디서든 사용할 수 있는 함수였을 것입니다.(`호이스팅`이 일어나기 때문)

```js
hello(); // Uncaught TypeError: hello is not a function
var hello = function() {
  console.log("안녕하세요");
};
```

위에서 말씀 드렸듯이 함수 리터럴은 `호이스팅`이 일어나지 않기 때문에 타입 에러가 발생합니다.

## 객체의 메서드

객체의 key(프로퍼티) 중에서 함수 객체의 참조를 값으로 담고있는 key를 `메서드`라고 부릅니다. 쉽게 말하면 함수를 value로 가지고 있는 key가 메서드 입니다.

```js
var person = {
  name: "junjang",
  age: 28,
  about: function() {
    return `안녕하세요 제 이름은 ${this.name}이고 나이는 ${this.age}입니다. 잘부탁드립니다 :)`;
  },
  changeInfo: function(name, age) {
    this.name = name;
    this.age = age;
  }
};
```

여기서 about, changeInfo 메서드에서 가리키는 `this`는 그 함수를 메서드로 가지고 있는 `객체`를 가리킵니다. 현재 예제에서는 person을 가리킨다고 보면 됩니다.<br/><br/>
보통 메서드는 일반적으로 메서드가 속한 객체의 `내부 데이터(프로퍼티 값)를 바꾸는` 용도로 사용이 됩니다.
